Excellent ğŸ‘
Now I will give you a **complete, structured, examiner-level guide** â€” from zero to final submission â€” including:

* Exact order of work
* What to calculate by hand
* What to implement in software
* Rules to follow
* How to avoid losing marks
* How to structure report
* How to validate everything

This is your **official execution roadmap** for the UR5 IK Verification Tool.

---

# ğŸ”· PROJECT OBJECTIVE (From Assignment)

As stated in the document (page 1â€“3 ), your tool must:

1. Model UR5 using DH parameters
2. Compute Forward Kinematics
3. Compute Inverse Kinematics
4. Compute Jacobian
5. Detect singularities
6. Verify IK using FK
7. Clearly indicate whether IK is valid

No physical robot required.

---

# ğŸŸ¢ OVERALL PROJECT RULES

Follow these strictly:

### RULE 1 â€” Use Standard DH Convention

Do NOT mix modified DH unless clearly stated.

---

### RULE 2 â€” Use Radians Only

All joint angles must be in radians in code.

---

### RULE 3 â€” Code Must Be Modular

As required in guidelines (page 2 ):

Separate files for:

* DH
* FK
* IK
* Jacobian
* Verification

---

### RULE 4 â€” Show Hand Calculations

You must show:

* DH parameter derivation
* At least 1 full transformation matrix derivation
* Jacobian column derivation
* IK algorithm explanation

---

### RULE 5 â€” Show Numerical Validation

Your tool must print:

* End-effector pose
* IK solution
* Position error
* Orientation error
* Jacobian determinant
* Singular or not

---

# ğŸŸ¢ STEP-BY-STEP PROCESS (FROM SCRATCH)

---

# ğŸ”µ STEP 1 â€” Understand UR5 Structure

UR5 has:

* 6 revolute joints
* Spherical wrist (last 3 joints intersect)

You must understand:

* Joint axes
* Link lengths
* Frame assignment

Draw coordinate frames in your notebook.

---

# ğŸ”µ STEP 2 â€” Create DH Table (HANDWRITTEN + CODE)

## 2.1 Handwritten Work

You must:

1. Draw frames 0 to 6
2. Identify:

   * ai
   * Î±i
   * di
   * Î¸i

Write the complete DH table manually.

Explain:

* Why Î±1 = Ï€/2
* Why a2 = -0.425
* Why d1 â‰  0

This proves understanding.

---

## 2.2 Implement in Code

Create:

```
dh_model.py
```

Write a function:

```
def dh_transform(a, alpha, d, theta):
```

Return 4Ã—4 transformation matrix.

---

# ğŸ”µ STEP 3 â€” Derive One Matrix Manually

Write full derivation:

[
T_i =
\begin{bmatrix}
\cos\theta & -\sin\theta \cos\alpha & ...
\end{bmatrix}
]

Substitute Î± value.

Simplify fully.

Only 1â€“2 matrices needed manually.

---

# ğŸ”µ STEP 4 â€” Implement Forward Kinematics

File:

```
forward_kinematics.py
```

Compute:

[
T_{06} = T_1 T_2 T_3 T_4 T_5 T_6
]

Extract:

Position:
[
x, y, z
]

Orientation:
Rotation matrix or RPY

---

## Validation Rule

Test with known configuration:

```
q = [0, 0, 0, 0, 0, 0]
```

Check if output looks physically reasonable.

---

# ğŸ”µ STEP 5 â€” Implement Jacobian

File:

```
jacobian.py
```

---

## 5.1 Handwritten Derivation

Write:

[
J_v = z_{i-1} \times (o_n - o_{i-1})
]

[
J_\omega = z_{i-1}
]

Show derivation of column 1 manually.

---

## 5.2 Code Implementation

Steps:

1. Compute all intermediate transformations
2. Extract:

   * zi
   * oi
3. Build 6Ã—6 Jacobian

---

## 5.3 Singularity Rule

Compute:

```
det(J)
```

If:

```
|det(J)| < 10^-6
```

â†’ Singular

Print warning.

---

# ğŸ”µ STEP 6 â€” Implement Inverse Kinematics

You have two options:

### Option A â€” Analytical IK

Hard, long derivation.

### Option B â€” Numerical IK (Recommended)

Use:

Pseudo-inverse method:

[
\Delta q = J^+ e
]

---

## 6.1 IK Algorithm (Must Write in Report)

1. Initialize q
2. Compute FK
3. Compute error
4. Compute Jacobian
5. Update q
6. Repeat until convergence

---

## 6.2 Convergence Rules

Stop if:

Position error < 1e-4
Orientation error < 1e-4
OR max iterations reached

---

# ğŸ”µ STEP 7 â€” IK Verification (Very Important)

As required in document (page 2 ):

After computing IK:

1. Apply FK to obtained joint angles
2. Compare with desired pose

---

## Compute Errors

Position error:

[
||p_d - p_c||
]

Orientation error:

Use rotation matrix difference.

---

## Validation Condition

If both errors small:

```
IK Solution Valid
```

Else:

```
IK Solution Invalid
```

This must be clearly printed.

---

# ğŸ”µ STEP 8 â€” Main Execution Flow

File:

```
main.py
```

Should:

1. Define desired pose
2. Call IK
3. Call verification
4. Compute Jacobian
5. Check singularity
6. Print results clearly

---

# ğŸ”µ STEP 9 â€” Testing Strategy

You must test:

### Test 1 â€” Random configuration

### Test 2 â€” Straight arm

### Test 3 â€” Near singularity

### Test 4 â€” Multiple initial guesses

Include results in report.

---

# ğŸ”µ STEP 10 â€” Report Structure

Your report.pdf must contain:

---

## 1ï¸âƒ£ Introduction

Explain problem statement.

---

## 2ï¸âƒ£ DH Modeling

* Frame assignment
* DH table
* Handwritten derivations
* One transformation matrix expanded

---

## 3ï¸âƒ£ Forward Kinematics

* Formula
* Matrix multiplication concept
* Example output

---

## 4ï¸âƒ£ Jacobian

* Formula
* One column derivation
* Singularity explanation

---

## 5ï¸âƒ£ Inverse Kinematics

* Method chosen
* Algorithm explanation
* Convergence criteria

---

## 6ï¸âƒ£ IK Verification

* Error computation formula
* Numerical results
* Validity statement

---

## 7ï¸âƒ£ Results

Include screenshots:

* FK output
* IK solution
* Error values
* Jacobian determinant

---

## 8ï¸âƒ£ Conclusion

Discuss:

* Accuracy
* Observations
* Singularities found

---

# ğŸŸ¢ SUBMISSION RULES (Very Important)

As per assignment (page 3 ):

Folder must be:

```
UR5_IK_Verification_<YourName>.zip
```

Structure:

```
UR5_IK_Verification/
â”‚â”€â”€ report.pdf
â”‚â”€â”€ code/
â”‚â”€â”€ results/
```

---

# ğŸŸ¢ COMMON MISTAKES (Avoid These)

âŒ Using degrees
âŒ Mixing modified and standard DH
âŒ Not verifying IK
âŒ No singularity detection
âŒ Messy output formatting
âŒ No handwritten derivations

---

# ğŸŸ¢ HOW EXAMINER WILL GRADE YOU

From evaluation criteria (page 3 ):

| Criteria            | What They Check          |
| ------------------- | ------------------------ |
| Correct DH          | Frame assignment correct |
| FK accuracy         | Matrix correct           |
| IK accuracy         | Converges properly       |
| Proper verification | Error calculation        |
| Code clarity        | Modular & readable       |

---

# ğŸŸ¢ WHAT A PERFECT PROJECT LOOKS LIKE

âœ” Clean modular Python
âœ” Small position error (<1e-4)
âœ” Proper singularity detection
âœ” Clear math derivation
âœ” Organized report
âœ” Clean folder structure

Thatâ€™s distinction-level work.

---

# ğŸ”¥ Final Advice

Think like a robotics software engineer:

* Math proves understanding
* Code proves implementation
* Verification proves correctness

This is exactly how real industrial robot controllers are validated.

---

If you want next, I can:

* Provide full Python modular template
* Help you write report section by section
* Walk through numerical IK implementation step-by-step
* Help you plan handwritten pages layout

Tell me your current progress and Iâ€™ll guide you precisely.